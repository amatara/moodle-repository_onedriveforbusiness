<?php


defined('MOODLE_INTERNAL') || die();
require_once($CFG->libdir.'/oauthlib.php');


/**
 * Functions to Oauth2 authenticate with Microsoft Windows Azure AD, and access the Office 365 Files REST API.
 *
 * @see http://msdn.microsoft.com/office/office365/howto/platform-development-overview
 *
 * @package    repository_onedriveforbusiness
 * @copyright  2014 Werner Urech
 * @author     Werner Urech <info Ã¤t itsu dot ch>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class oauth2_client_office365 extends oauth2_client
{


    protected $_loginhint;
    protected $_returnurl; // parent::$returnurl property is private, has no getter, cannot access it :-( ... so we use our own


    /**
     * Construct a onedriveforbusiness request object
     *
     * @param string $clientid -- client id for OAuth 2.0, generated by registering the application in Windows Azure AD
     * @param string $clientsecret -- client secret for OAuth 2.0, generated by registering the application in Windows Azure AD
     * @param moodle_url $returnurl -- url to return to after succsesful auth
     */
    public function __construct($clientid, $clientsecret, $loginhint, $returnurl)
    {
        $this->_loginhint = $loginhint;
        $this->_returnurl = $returnurl;
        parent::__construct($clientid, $clientsecret, $returnurl, null); // we don't need the scope param
    }


    /**
     * The Microsoft oauth2 authorize url.
     *
     * @see http://msdn.microsoft.com/en-us/library/azure/dn645542.aspx  ????
     *
     * @return string the auth url
     */
    protected function auth_url()
    {
        return "https://login.windows.net/common/oauth2/authorize";
    }


    /**
     * The Microsoft oauth2 token url.
     *
     * @return string the auth url
     */
    protected function token_url()
    {
        return "https://login.windows.net/common/oauth2/token";
    }


    /**
     * Assemble the login url of the external oauth provider for starting the login process.
     *
     * @return moodle_url -- external oauth login url
     */
    public function get_login_url()
    {
        global $USER;

        $loginhint = '';
        if (!empty($this->_loginhint)) {
            $loginhint = str_ireplace('{username}', $USER->username, $this->_loginhint);
        }

        $url = new moodle_url(
            $this->auth_url(),
            array(
                'client_id' => $this->get_clientid(),
                'response_type' => 'code',
                'redirect_uri' => self::callback_url()->out(false),
                'state' => $this->_returnurl->out_as_local_url(false),
                'login_hint' => $loginhint,
            )
        );

        return $url;
    }


    /**
     * Trade in our initial authorization code for an access token and a refresh token.
     *
     * We need to extend the parent method to make it work with MS properties: resource, refresh_token
     *
     * @see parent::upgrade_token()
     *
     * @param string $code -- the code returned from the nitial external oauth login
     * @return boolean -- true on success | false on fail
     */
    public function upgrade_token($code)
    {
//        $e = new Exception;
//        error_log(var_export($e->getTraceAsString(), true));
        $params = array(
            'client_id' => $this->get_clientid(),
            'client_secret' => $this->get_clientsecret(),
            'grant_type' => 'authorization_code',
            'code' => $code,
            'redirect_uri' => self::callback_url()->out(false),
            'resource' => 'https://api.office.com/discovery/',
        );

        $response = $this->post($this->token_url(), $params);

        if (!$this->info['http_code'] === 200) {
            throw new moodle_exception('Could not upgrade oauth token');
        }

        $r = json_decode($response);
//        error_log(__FUNCTION__ . ' ' . print_r($r, true));

        if (!isset($r->access_token)) {
            return false;
        }

        // store the access token, it's expiry time, and the refresh token
        $tokenstuff = new stdClass;
        $tokenstuff->token = $r->access_token;
        $tokenstuff->expires = (time() + ($r->expires_in - 60)); // expires a minute before actual expiry
        $tokenstuff->refresh_token = $r->refresh_token;
        $this->store_token($tokenstuff);
//        error_log(__FUNCTION__ . ' ' . print_r($this->get_accesstoken(), true));

        return true;
    }


    /**
     * Discover the specified Office 365 service endpoint for the logged-in user.
     *
     * If success, store the service info together with the tokens.
     *
     * @param string $capability -- identifies the service resource that we want
     * @return bool -- false on error, true on success
     */
    public function discover_service($capability = 'MyFiles')
    {
        $response = $this->request('https://api.office.com/discovery/v1.0/me/services');
//        error_log(__FUNCTION__ . ' ' . print_r($this->get_info(), true)); // curl info

        if ($this->errno) {
            error_log(__FUNCTION__ . '() -- error: ' . $this->error . ' -- code: ' . $this->errno);
            return false;
        }

        $json = json_decode($response);
//        error_log(__FUNCTION__ . ' ' . print_r($json, true));

        if (isset($json->error)) {
            error_log(__FUNCTION__ . '() -- error: ' . $json->error->message . ' -- code: ' . $json->error->code);
            return false;
        }

        $service = null;
        foreach ($json->value as $resource) {
            if ($capability == $resource->capability) {
                $service = $resource;
                break;
            }
        }

        if (empty($service)) {
            error_log(__FUNCTION__ . "() -- error: could not find service endpoint resource with '{$capability}' capability");
            return false;
        }
//        error_log(__FUNCTION__ . '() -- ' . print_r($service, true));

        $tokenstuff = $this->get_accesstoken();
        $tokenstuff->service = $service;
        $this->store_token($tokenstuff);

        return true;
    }


    /**
     * Request new access and refresh tokens for the specified resource, by presenting the current refresh token.
     *
     * @param string $resource -- the resource for which we request the token... default is $this->get_accesstoken()->service->serviceResourceId
     * @return boolean true if token is upgraded succesfully
     */
    public function refresh_tokens($resource = null)
    {
        $callbackurl = self::callback_url();
        $params = array(
            'client_id' => $this->get_clientid(),
            'client_secret' => $this->get_clientsecret(),
            'grant_type' => 'refresh_token',
            'refresh_token' => $this->get_accesstoken()->refresh_token,
            'resource' => empty($resource) ? $this->get_accesstoken()->service->serviceResourceId : $resource,
        );

        $response = $this->post($this->token_url(), $params);

        if (!$this->info['http_code'] === 200) {
            throw new moodle_exception('Could not upgrade oauth token');
        }

        $r = json_decode($response);
//        error_log(__FUNCTION__ . '() -- ' . print_r($r, true));
        if (!isset($r->access_token)) {
            return false;
        }

        // store the access token, it's expiry time, the refresh token, and the service
        $tokenstuff = new stdClass();
        $tokenstuff->token = $r->access_token;
        $tokenstuff->expires = (time() + ($r->expires_in - 60)); // expires a minute before actual expiry
        $tokenstuff->refresh_token = $r->refresh_token;
        $tokenstuff->service = $this->get_accesstoken()->service;
        $this->store_token($tokenstuff);

        return true;
    }


    /**
     * Make a REST request that works with Office 365 API v1.0
     *
     * The GET request needs headers:
     * - Authorization: the access token
     * - Accept: specify the answer content type... NOT ALLOWED ANYMORE, results in an error in the v1.0 API which by default delivers odata v4
     *
     * @param string $url -- the REST URL
     * @param array $options -- curl options, passed thru to curl::request()
     * @return bool
     */
    protected function request($url, $options = array())
    {
        $murl = new moodle_url($url);

        if ($this->get_accesstoken()) {
            $this->setHeader(array(
//                'Accept: application/json;odata=verbose', // NOT with API v1.0
                'Authorization: Bearer ' . $this->get_accesstoken()->token,
            ));
        }

        return curl::request($murl->out(false), $options);
    }


    /**
     * Returns a list of files in the specified path.
     *
     * @param string $path -- the path which we are in
     * @return array -- array of files, formatted as required by the repository class. empty array on failure
     */
    public function get_file_list($path = '')
    {
        global $OUTPUT;
//        error_log(__FUNCTION__ . "() -- path: $path");

        if (empty($path)) {
            $url = $this->get_accesstoken()->service->serviceEndpointUri . '/files/root/children';
        } else {
            $url = $this->get_accesstoken()->service->serviceEndpointUri . "/files/getByPath('" . rawurlencode($path) . "')/children";
        }
//        error_log(__FUNCTION__ . "() -- REST request url: $url");

        // REST request the json-encoded file list for the given path
        $response = $this->request($url);
        if (200 != $this->info['http_code']) {
            error_log(__FUNCTION__ . ' ' . print_r($this->get_info(), true)); // curl info
            return array();
        }
        if ($this->errno) {
            error_log(__FUNCTION__ . '() -- error: ' . $this->error . ' -- code: ' . $this->errno);
            return array();
        }
        $json = json_decode($response);
//        error_log(__FUNCTION__ . '() -- ' . print_r($json, true));
        if (isset($json->error)) {
            error_log(__FUNCTION__ . '() -- error: ' . $json->error->message . ' -- code: ' . $json->error->code);
            $this->log_out();
            return array();
        }

        // build the file list for the filepicker
        $files = array();
        foreach ($json->value as $file) {
            switch($file->type) {
                case 'Folder':
                    $path = $file->parentReference->path . '/' . $file->name;
                    $path = strtr($path, '//', '/');
                    $files[] = array(
                        'title' => $file->name,
                        'path' => $path,
                        'size' => 0,
                        'date' => strtotime($file->dateTimeLastModified),
                        'thumbnail' => $OUTPUT->pix_url(file_folder_icon(90))->out(false),
                        'children' => array(), // empty, we do dynamic loading of subfolder contents, when folder is clicked
                    );
                    break;
                case 'File':
                    $files[] = array(
                        'title' => $file->name,
                        'size' => $file->size,
                        'date' => strtotime($file->dateTimeLastModified),
                        'thumbnail' => $OUTPUT->pix_url(file_extension_icon($file->name, 90))->out(false),
                        'source' => $file->contentUrl, // link to download the file contents
                        'url' => $file->webUrl, // link to open the file in the browser on the Office 365 / OneDrive for Business website
                        'author' => $file->createdBy->user->displayName,
                    );
                    break;
            }
        }
        return $files;
    }


    /**
     * Download a file from repo using authenticated request
     *
     * @param string $contenturl -- direct url to retrieve the file
     * @param string $path -- local path to save file to
     * @return array -- struct matching repository::get_file() result
     */
    public function download_file($contenturl, $path)
    {
        global $CFG;
        // use the curl::download_one() function... which uses $this->request(), where we add the auth token
        $result = $this->download_one($contenturl, null, array('filepath' => $path, 'timeout' => $CFG->repositorygetfiletimeout));
        if ($result !== true) {
            throw new moodle_exception('errorwhiledownload', 'repository', '', $result);
        }
        return array('path' => $path, 'url' => $contenturl);
    }


    /**
     * Get the url to the Office 365 OneDrive website, for displaying a link in the filepicker.
     *
     * @return string -- url of online file manager
     */
    public function get_manage_url()
    {
        if (isset($this->get_accesstoken()->service->serviceResourceId)) {
            return $this->get_accesstoken()->service->serviceResourceId;
        } else {
            return '';
        }
    }


    /**
     * The session key under which we store the access_token (and our additions to it).
     *
     * @return string
     */
    protected function get_tokenname()
    {
        return get_class($this).'-'.md5($this->get_clientid());
    }


}
